PIC microcontrollers

==History==
===Original concept===
thumb
The original PIC was intended to be used with General Instrument's new CP1600 16-bit central processing unit (CPU). The CP1600 was a powerful processor for its era, implementing most of the PDP-11 minicomputer's instruction set architecture in a microcomputer package.
Whilst most people considered the CP1600 a good CPU, it had one significant problem; to reduce pin count of its physical DIP packaging, the address bus and data bus shared pins. For CPUs that had separate I/O channels, like the Intel 8008, this would not have been a problem, but the 1600 also used the PDP-11's Memory-mapped I/O concept. This meant that communicating with a device required the device to watch for key memory locations being accessed on one machine cycle, and then read the data on the next. This made I/O on the machine slower as the bus alternated between address and data modes, and more expensive to implement as the devices had to latch inputs over multiple cycles. All of this complexity was repeated on the CPU side in the corresponding device driver.
To address this shortcoming of the 1600, the 8-bit PIC was developed in 1975. The idea was that a system would have one or more of the low-cost PICs performing the actual I/O with the devices, and then sending that data to the CPU. The PIC used simple microcode stored in ROM to perform its tasks, and although the term RISC was not used at the time, it shares some common features with RISC designs.
===After the 1600===
In 1985, General Instrument sold their microelectronics division and the new owners cancelled almost everything which by this time was mostly out-of-date. The PIC, however, was upgraded with an internal EPROM to produce a programmable Channel I/O.
At the same time Plessey in the UK released NMOS processors numbered PIC1650 and PIC1655 based on the GI design, using the same instruction sets, either user mask programmable or versions pre-programed for auto-diallers and keyboard interfaces. <ref>Plessey Satellite Cable TV Integrated Circuit Handbook May 1986</ref> 
In 1998 Microchip introduced the PIC 16F84, a flash programmable and erasable version of its successful serial programmable PIC16C84. 
In 2001, Microchip introduced more Flash programmable devices, with full production commencing in 2002. urltoken 
Today, a huge variety of PICs are available with various on-board peripherals (serial communication modules, UARTs, motor control kernels, etc.) and program memory from 256 words to 64K words and more (a "word" is one assembly language instruction, varying in length from 8 to 16 bits, depending on the specific PIC micro family).
PIC and PICmicro are now registered trademarks of Microchip Technology. It is generally thought that PIC stands for Peripheral Interface Controller, although General Instruments' original acronym for the initial PIC1640 and PIC1650 devices was "Programmable Interface Controller".<ref name="1976databook"/> The acronym was quickly replaced with "Programmable Intelligent Computer".<ref name="1977catalog"/>
The Microchip 16C84 (PIC16x84), introduced in 1993, was the first<ref></ref> Microchip CPU with on-chip EEPROM memory. 
By 2013, Microchip was shipping over one billion PIC microcontrollers every year.<ref>
</ref>
==Device families==
PIC micro chips are designed with a Harvard architecture, and are offered in various device families. The baseline and mid-range families use 8-bit wide data memory, and the high-end families use 16-bit data memory. The latest series, PIC32MZ is a 32-bit MIPS-based microcontroller. Instruction words are in sizes of 12-bit (PIC10 and PIC12), 14-bit (PIC16) and 24-bit (PIC24 and dsPIC). The binary representations of the machine instructions vary by family and are shown in PIC instruction listings.
Within these families, devices may be designated PICnnCxxx (CMOS) or PICnnFxxx (Flash). "C" devices are generally classified as "Not suitable for new development" (not actively promoted by Microchip). The program memory of "C" devices is variously described as OTP, ROM, or EEPROM. As of October 2016, the only OTP product classified as "In production" is the pic16HV540. "C" devices with quartz windows (for erasure), are in general no longer available.
===PIC10 and PIC12===
 
These devices feature a 12-bit wide code memory, a 32-byte register file, and a tiny two level deep call stack. They are represented by the PIC10 series, as well as by some PIC12 and PIC16 devices. Baseline devices are available in 6-pin to 40-pin packages.
Generally the first 7 to 9 bytes of the register file are special-purpose registers, and the remaining bytes are general purpose RAM. Pointers are implemented using a register pair: after writing an address to the FSR (file select register), the INDF (indirect f) register becomes an alias for the addressed register. 
If banked RAM is implemented, the bank number is selected by the high 3 bits of the FSR. This affects register numbers 16–31; registers 0–15 are global and not affected by the bank select bits.
Because of the very limited register space (5 bits), 4 rarely read registers were not assigned addresses, but written by special instructions (<code>OPTION</code> and <code>TRIS</code>).
The ROM address space is 512 words (12 bits each), which may be extended to 2048 words by banking. <code>CALL</code> and <code>GOTO</code> instructions specify the low 9 bits of the new code location; additional high-order bits are taken from the status register. Note that a CALL instruction only includes 8 bits of address, and may only specify addresses in the first half of each 512-word page.
Lookup tables are implemented using a computed <code>GOTO</code> (assignment to PCL register) into a table of <code>RETLW</code> instructions.
This "baseline core" does not support interrupts; all I/O must be polled. There are some "enhanced baseline" variants with interrupt support and a four-level call stack.
PIC10F32x devices feature a mid-range 14-bit wide code memory of 256 or 512 words, a 64-byte SRAM register file, and an 8-level deep hardware stack. These devices are available in 6-pin SMD and 8-pin DIP packages (with two pins unused). One input only and three I/O pins are available. A complex set of interrupts are available. Clocks are an internal calibrated high-frequency oscillator of 16&nbsp;MHz with a choice of selectable speeds via software and a 31&nbsp;kHz low-power source.
===PIC16===
These devices feature a 14-bit wide code memory, and an improved 8-level deep call stack. The instruction set differs very little from the baseline devices, but the two additional opcode bits allow 128 registers and 2048 words of code to be directly addressed. There are a few additional miscellaneous instructions, and two additional 8-bit literal instructions, add and subtract. The mid-range core is available in the majority of devices labeled PIC12 and PIC16.
The first 32 bytes of the register space are allocated to special-purpose registers; the remaining 96 bytes are used for general-purpose RAM. If banked RAM is used, the high 16 registers (0x70–0x7F) are global, as are a few of the most important special-purpose registers, including the STATUS register which holds the RAM bank select bits. (The other global registers are FSR and INDF, the low 8 bits of the program counter PCL, the PC high preload register PCLATH, and the master interrupt control register INTCON.)
The PCLATH register supplies high-order instruction address bits when the 8 bits supplied by a write to the PCL register, or the 11 bits supplied by a <code>GOTO</code> or <code>CALL</code> instruction, is not sufficient to address the available ROM space.
===PIC17===
The 17 series never became popular and has been superseded by the PIC18 architecture (however, see clones below). The 17 series is not recommended for new designs, and availability may be limited to users.
Improvements over earlier cores are 16-bit wide opcodes (allowing many new instructions), and a 16-level deep call stack. PIC17 devices were produced in packages from 40 to 68 pins.
The 17 series introduced a number of important new features:<ref></ref>
* a memory mapped accumulator
* read access to code memory (table reads)
* direct register to register moves (prior cores needed to move registers through the accumulator)
* an external program memory interface to expand the code space
* an 8-bit × 8-bit hardware multiplier
* a second indirect register pair
* auto-increment/decrement addressing controlled by control bits in a status register (ALUSTA)
A significant limitation was that RAM space was limited to 256 bytes (26 bytes of special function registers, and 232 bytes of general-purpose RAM), with awkward bank-switching in the models that supported more.
===PIC18===
 
In 2000, Microchip introduced the PIC18 architecture. Unlike the 17 series, it has proven to be very popular, with a large number of device variants presently in manufacture. In contrast to earlier devices, which were more often than not programmed in assembly, C has become the predominant development language.<ref></ref>
The 18 series inherits most of the features and instructions of the 17 series, while adding a number of important new features:
* call stack is 21 bits wide and much deeper (31 levels deep)
* the call stack may be read and written (TOSU:TOSH:TOSL registers)
* conditional branch instructions
* indexed addressing mode (PLUSW)
* extending the FSR registers to 12 bits, allowing them to linearly address the entire data address space
* the addition of another FSR register (bringing the number up to 3)
The RAM space is 12&nbsp;bits, addressed using a 4-bit bank select register and an 8-bit offset in each instruction. An additional "access" bit in each instruction selects between bank 0 (a=0) and the bank selected by the BSR (a=1).
A 1-level stack is also available for the STATUS, WREG and BSR registers. They are saved on every interrupt, and may be restored on return. If interrupts are disabled, they may also be used on subroutine call/return by setting the s bit (appending ", FAST" to the instruction).
The auto increment/decrement feature was improved by removing the control bits and adding four new indirect registers per FSR. Depending on which indirect file register is being accessed it is possible to postdecrement, postincrement, or preincrement FSR; or form the effective address by adding W to FSR.
In more advanced PIC18 devices, an "extended mode" is available which makes the addressing even more favorable to compiled code:
* a new offset addressing mode; some addresses which were relative to the access bank are now interpreted relative to the FSR2 register
* the addition of several new instructions, notable for manipulating the FSR registers.
PIC18 devices are still developed (2017) and fitted with CIP (Core Independent Peripherals)
===PIC24 and dsPIC===
 
In 2001, Microchip introduced the dsPIC series of chips,<ref> urltoken which entered mass production in late 2004. They are Microchip's first inherently 16-bit microcontrollers. PIC24 devices are designed as general purpose microcontrollers. dsPIC devices include digital signal processing capabilities in addition.
Although still similar to earlier PIC architectures, there are significant enhancements:<ref></ref>
* All registers are 16 bits wide
* Program counter is 22 bits (Bits 22:1; bit 0 is always 0)
* Instructions are 24 bits wide
* Data address space expanded to 64&nbsp;KiB
* First 2&nbsp;KiB is reserved for peripheral control registers
* Data bank switching is not required unless RAM exceeds 62&nbsp;KiB
* "f operand" direct addressing extended to 13 bits (8&nbsp;KiB)
* 16 W registers available for register-register operations.<br />(But operations on f operands always reference W0.)
* Instructions come in byte and (16-bit) word forms
* Stack is in RAM (with W15 as stack pointer); there is no hardware stack
* W14 is the frame pointer
* Data stored in ROM may be accessed directly ("Program Space Visibility")
* Vectored Interrupts for different interrupt sources
Some features are:
* (16×16)-bit single-cycle multiplication and other digital signal processing operations
* hardware multiply–accumulate (MAC)
* hardware divide assist (19 cycles for 32/16-bit divide)
* barrel shifter - For both accumulators and general purpose registers
* bit reversal
* hardware support for loop indexing
* peripheral direct memory access
dsPICs can be programmed in C using Microchip's XC16 compiler (formerly called C30) which is a variant of GCC.
Instruction ROM is 24 bits wide. Software can access ROM in 16-bit words, where even words hold the least significant 16 bits of each instruction, and odd words hold the most significant 8 bits. The high half of odd words reads as zero. The program counter is 23 bits wide, but the least significant bit is always 0, so there are 22 modifiable bits.
Instructions come in two main varieties, with most important operations (add, xor, shifts, etc.) allowing both forms.
The first is like the classic PIC instructions, with an operation between a specified f register (i.e. the first 8K of RAM) and a single accumulator W0, with a destination select bit selecting which is updated with the result. (The W registers are memory-mapped. so the f operand may be any W register.)
The second form is more conventional, allowing three operands, which may be any of 16 W registers. The destination and one of the sources also support addressing modes, allowing the operand to be in memory pointed to by a W register.
===PIC32M MIPS-based line===
====PIC32MX====
In November 2007, Microchip introduced the urltoken PIC32MX family of 32-bit microcontrollers, based on the MIPS32 M4K Core.<ref></ref> The device can be programmed using the urltoken Microchip MPLAB C Compiler for PIC32 MCUs, a variant of the GCC compiler. The first 18 models currently in production (PIC32MX3xx and PIC32MX4xx) are pin to pin compatible and share the same peripherals set with the PIC24FxxGA0xx family of (16-bit) devices allowing the use of common libraries, software and hardware tools. Today, starting at 28 pin in small QFN packages up to high performance devices with Ethernet, CAN and USB OTG, full family range of mid-range 32-bit microcontrollers are available.
The PIC32 architecture brought a number of new features to Microchip portfolio, including:
* The highest execution speed 80&nbsp;MIPS (120+<ref></ref> Dhrystone 
* The largest flash memory: 512&nbsp;kB
* One instruction per clock cycle execution
* The first cached processor
* Allows execution from RAM
* Full Speed Host/Dual Role and OTG USB capabilities
* Full JTAG and 2-wire programming and debugging
* Real-time trace
====PIC32MZ====
In November 2013, Microchip introduced the PIC32MZ series of microcontrollers, based on the MIPS M14K core. The PIC32MZ series include:<ref></ref><ref></ref>
* 252 MHz core speed, 415 DMIPS
* Up to 2&nbsp;MB Flash and 512KB RAM
* New peripherals including high-speed USB, crypto engine and SQI
In 2015, Microchip released the PIC32MZ EF family, using the updated MIPS M5150 Warrior M-class processor.<ref></ref><ref> urltoken 
In 2017, Microchip introduced the PIC32MZ DA Family, featuring an integrated Graphics Controller, Graphics Processor and 32MB of DDR2 DRAM.<ref></ref><ref></ref>
====PIC32MM====
In June 2016, Microchip introduced the PIC32MM family, specialized for low-power and low-cost applications.<ref></ref> The PIC32MM features core-independent peripherals, sleep modes down to 500 nA, and 4 x 4&nbsp;mm packages.<ref> urltoken The PIC32MM microcontrollers use the MIPS Technologies M4K, a 32-bit MIPS32 processor.
They are meant for very low power consumption and limited to 25&nbsp;MHz.
Their key advantage is to support the 16bits instructions of MIPS making program size much more compact (about 40%)
====PIC32MK====
Microchip introduced the PIC32MK family in 2017, specialized for motor control, industrial control, Industrial Internet of Things (IIoT) and multi-channel CAN applications.<ref></ref>
==Core architecture==
The PIC architecture is characterized by its multiple attributes:
* Separate code and data spaces (Harvard architecture).
** Except PIC32: The MIPS M4K architecture's separate data and instruction paths are effectively merged into a single common address space by the System Bus Matrix module.
* A small number of fixed-length instructions
* Most instructions are single-cycle (2 clock cycles, or 4 clock cycles in 8-bit models), with one delay cycle on branches and skips
* One accumulator (W0), the use of which (as source operand) is implied (i.e. is not encoded in the opcode)
* All RAM locations function as registers as both source and/or destination of math and other functions.<ref> urltoken 
* A hardware stack for storing return addresses
* A small amount of addressable data space (32, 128, or 256 bytes, depending on the family), extended through banking
* Data-space mapped CPU, port, and peripheral registers
* ALU status flags are mapped into the data space
* The program counter is also mapped into the data space and writable (this is used to implement indirect jumps).
There is no distinction between memory space and register space because the RAM serves the job of both memory and registers, and the RAM is usually just referred to as the register file or simply as the registers.
===Data space (RAM)===
PICs have a set of registers that function as general-purpose RAM. Special-purpose control registers for on-chip hardware resources are also mapped into the data space. The addressability of memory varies depending on device series, and all PIC devices have some Bank switching to extend addressing to additional memory. Later series of devices feature move instructions, which can cover the whole addressable space, independent of the selected bank. In earlier devices, any register move had to be achieved through the accumulator.
To implement indirect addressing, a "file select register" (FSR) and "indirect register" (INDF) are used. A register number is written to the FSR, after which reads from or writes to INDF will actually be from or to the register pointed to by FSR. Later devices extended this concept with post- and pre- increment/decrement for greater efficiency in accessing sequentially stored data. This also allows FSR to be treated almost like a stack pointer (SP).
External data memory is not directly addressable except in some PIC18 devices with high pin count.
===Code space===
The code space is generally implemented as on-chip ROM, EPROM or flash ROM. In general, there is no provision for storing code in external memory due to the lack of an external memory interface. The exceptions are PIC17 and select high pin count PIC18 devices.<ref></ref>
===Word size===
All PICs handle (and address) data in 8-bit chunks. However, the unit of addressability of the code space is not generally the same as the data space. For example, PICs in the baseline (PIC12) and mid-range (PIC16) families have program memory addressable in the same wordsize as the instruction width, i.e. 12 or 14 bits respectively. In contrast, in the PIC18 series, the program memory is addressed in 8-bit increments (bytes), which differs from the instruction width of 16 bits.
In order to be clear, the program memory capacity is usually stated in number of (single-word) instructions, rather than in bytes.
===Stacks===
PICs have a hardware call stack, which is used to save return addresses. The hardware stack is not software-accessible on earlier devices, but this changed with the 18 series devices.
Hardware support for a general-purpose parameter stack was lacking in early series, but this greatly improved in the 18 series, making the 18 series architecture more friendly to high-level language compilers.
===Instruction set===
 
PIC's instructions vary from about 35 instructions for the low-end PICs to over 80 instructions for the high-end PICs. The instruction set includes instructions to perform a variety of operations on registers directly, the accumulator and a literal constant or the accumulator and a register, as well as for conditional execution, and program branching.
Some operations, such as bit setting and testing, can be performed on any numbered register, but bi-operand arithmetic operations always involve W (the accumulator), writing the result back to either W or the other operand register. To load a constant, it is necessary to load it into W before it can be moved into another register. On the older cores, all register moves needed to pass through W, but this changed on the "high-end" cores.
PIC cores have skip instructions, which are used for conditional execution and branching. The skip instructions are "skip if bit set" and "skip if bit not set". Because cores before PIC18 had only unconditional branch instructions, conditional jumps are implemented by a conditional skip (with the opposite condition) followed by an unconditional branch. Skips are also of utility for conditional execution of any immediate single following instruction. It is possible to skip skip instructions. For example, the instruction sequence "skip if A; skip if B; C" will execute C if A is true or if B is false.
The 18 series implemented shadow registers, registers which save several important registers during an interrupt, providing hardware support for automatically saving processor state when servicing interrupts.
In general, PIC instructions fall into five classes:
# Operation on working register (WREG) with 8-bit immediate ("literal") operand. E.g. <code>movlw</code> (move literal to WREG), <code>andlw</code> (AND literal with WREG). One instruction peculiar to the PIC is <code>retlw</code>, load immediate into WREG and return, which is used with computed branches to produce lookup tables.
# Operation with WREG and indexed register. The result can be written to either the Working register (e.g. <code>addwf reg,w</code>). or the selected register (e.g. <code>addwf reg,f</code>).
# Bit operations. These take a register number and a bit number, and perform one of 4 actions: set or clear a bit, and test and skip on set/clear. The latter are used to perform conditional branches. The usual ALU status flags are available in a numbered register so operations such as "branch on carry clear" are possible.
# Control transfers. Other than the skip instructions previously mentioned, there are only two: <code>goto</code> and <code>call</code>.
# A few miscellaneous zero-operand instructions, such as return from subroutine, and <code>sleep</code> to enter low-power mode.
===Performance===
The architectural decisions are directed at the maximization of speed-to-cost ratio. The PIC architecture was among the first scalar CPU designs and is still among the simplest and cheapest. The Harvard architecture, in which instructions and data come from separate sources, simplifies timing and microcircuit design greatly, and this benefits clock speed, price, and power consumption.
The PIC instruction set is suited to implementation of fast lookup tables in the program space. Such lookups take one instruction and two instruction cycles. Many functions can be modeled in this way. Optimization is facilitated by the relatively large program space of the PIC (e.g. 4096 × 14-bit words on the 16F690) and by the design of the instruction set, which allows embedded constants. For example, a branch instruction's target may be indexed by W, and execute a "RETLW", which does as it is named return with literal in W.
Interrupt latency is constant at three instruction cycles. External interrupts have to be synchronized with the four-clock instruction cycle, otherwise there can be a one instruction cycle jitter. Internal interrupts are already synchronized. The constant interrupt latency allows PICs to achieve interrupt-driven low-jitter timing sequences. An example of this is a video sync pulse generator. This is no longer true in the newest PIC models, because they have a synchronous interrupt latency of three or four cycles.
===Advantages===
* Small instruction set to learn
* RISC architecture
* Built-in oscillator with selectable speeds
* Easy entry level, in-circuit programming plus in-circuit debugging PICkit units available for less than $50
* Inexpensive microcontrollers
* Wide range of interfaces including I²C, SPI, USB, USART, A/D, programmable comparators, PWM, LIN, CAN, PSP, and Ethernet<ref></ref>
* Availability of processors in DIL package make them easy to handle for hobby use.
===Limitations===
* One accumulator
* Register-bank switching is required to access the entire RAM of many devices
* Operations and registers are not orthogonal; some instructions can address RAM and/or immediate constants, while others can use the accumulator only.
The following stack limitations have been addressed in the PIC18 series, but still apply to earlier cores:
* The hardware call stack is not addressable, so preemptive task switching cannot be implemented
* Software-implemented stacks are not efficient, so it is difficult to generate reentrant code and support local variables
With paged program memory, there are two page sizes to worry about: one for CALL and GOTO and another for computed GOTO (typically used for table lookups). For example, on PIC16, CALL and GOTO have 11 bits of addressing, so the page size is 2048 instruction words. For computed GOTOs, where you add to PCL, the page size is 256 instruction words. In both cases, the upper address bits are provided by the PCLATH register. This register must be changed every time control transfers between pages. PCLATH must also be preserved by any interrupt handler.<ref></ref>
===Compiler development===
While several commercial compilers are available, in 2008, Microchip released their own C compilers, C18 and C30, for the line of 18F 24F and 30/33F processors.
As of 2013, Microchip offers their XC series of compilers, for use with MPLAB. Microchip will eventually phase out its older compilers, such as C18, and recommends using their XC series compilers for new designs.<ref></ref>
The RISC instruction set of the PIC assembly language code can make the overall flow difficult to comprehend. Judicious use of simple macros can increase the readability of PIC assembly language. For example, the original Parallax PIC assembler ("SPASM") has macros, which hide W and make the PIC look like a two-address machine. It has macro instructions like <code>mov b, a</code> (move the data from address a to address b) and <code>add b, a</code> (add data from address a to data in address b). It also hides the skip instructions by providing three-operand branch macro instructions, such as <code>cjne a, b, dest</code> (compare a with b and jump to dest if they are not equal).
==Hardware features==
PIC devices generally feature:
* Flash memory (program memory, programmed using MPLAB devices)
* SRAM (data memory)
* EEPROM memory (programmable at run-time)
* Sleep mode (power savings)
* Watchdog timer
* Various crystal or RC oscillator configurations, or an external clock
===Variants===
Within a series, there are still many device variants depending on what hardware resources the chip features:
* GPIO
* Internal clock oscillators
* 8/16/32&nbsp;bit timers
* Synchronous/Asynchronous Serial Interface USART
* MSSP Peripheral for I²C and SPI communications
* Capture/Compare and PWM modules
* Analog-to-digital converters (up to ~1.0 Msps)
* USB, Ethernet, CAN interfacing support
* External memory interface
* Integrated analog RF front ends (PIC16F639, and rfPIC).
* KeeLoq Rolling code encryption peripheral (encode/decode)
* And many more
===Trends===
The first generation of PICs with EPROM storage are almost completely replaced by chips with Flash memory. Likewise, the original 12-bit instruction set of the PIC1650 and its direct descendants has been superseded by 14-bit and 16-bit instruction sets. Microchip still sells OTP (one-time-programmable) and windowed (UV-erasable) versions of some of its EPROM based PICs for legacy support or volume orders. The Microchip website lists PICs that are not electrically erasable as OTP. UV erasable windowed versions of these chips can be ordered.
===Part number===
The F in a PICMicro part number generally indicates the PICmicro uses flash memory and can be erased electronically. Conversely, a C generally means it can only be erased by exposing the die to ultraviolet light (which is only possible if a windowed package style is used). An exception to this rule is the PIC16C84 which uses EEPROM and is therefore electrically erasable.
An L in the name indicates the part will run at a lower voltage, often with frequency limits imposed.<ref name="3vdesign"></ref> Parts designed specifically for low voltage operation, within a strict range of 3 - 3.6 volts, are marked with a J in the part number. These parts are also uniquely I/O tolerant as they will accept up to 5&nbsp;V as inputs.<ref name="3vdesign" />
==Development tools==
Microchip provides a freeware IDE package called MPLAB, which includes an assembler, linker, software simulator, and debugger. They also sell C compilers for the PIC10, PIC12, PIC16, PIC18, PIC24, PIC32 and dsPIC, which integrate cleanly with MPLAB X. Free versions of the C compilers are also available with all features. But for the free versions, optimizations will be disabled after 60 days.<ref></ref>
Several third parties develop C language compilers for PICs, many of which integrate to MPLAB and/or feature their own IDE. A fully featured compiler for the PICBASIC language to program PIC microcontrollers is available from meLabs, Inc. Mikroelektronika offers PIC compilers in C, BASIC and Pascal programming languages.
A graphical programming language, Flowcode, exists capable of programming 8- and 16-bit PIC devices and generating PIC-compatible C code. It exists in numerous versions from a free demonstration to a more complete professional edition.
The Proteus Design Suite is able to simulate many of the popular 8 and 16-bit PIC devices along with other circuitry that is connected to the PIC on the schematic. The program to be simulated can be developed within Proteus itself, MPLAB or any other development tool.<ref></ref>
==Device programmers==
Devices called "programmers" are traditionally used to get program code into the target PIC. Most PICs that Microchip currently sells feature ICSP (In Circuit Serial Programming) and/or LVP (Low Voltage Programming) capabilities, allowing the PIC to be programmed while it is sitting in the target circuit.
Microchip offers programmers/debuggers under the MPLAB and PICKit series. MPLAB ICD4 and MPLAB REAL ICE are the current programmers and debuggers for professional engineering, while PICKit 3 is a low-cost programmer / debugger line for hobbyists and students.
===Bootloading===
Many of the higher end flash based PICs can also self-program (write to their own program memory), a process known as bootloading. Demo boards are available with a small bootloader factory programmed that can be used to load user programs over an interface such as RS-232 or USB, thus obviating the need for a programmer device.
Alternatively there is bootloader firmware available that the user can load onto the PIC using ICSP. After programming the bootloader onto the PIC, the user can then reprogram the device using RS232 or USB, in conjunction with specialized computer software.
The advantages of a bootloader over ICSP is faster programming speeds, immediate program execution following programming, and the ability to both debug and program using the same cable.
===Third party===
There are many programmers for PIC microcontrollers, ranging from the extremely simple designs which rely on ICSP to allow direct download of code from a host computer, to intelligent programmers that can verify the device at several supply voltages. Many of these complex programmers use a pre-programmed PIC themselves to send the programming commands to the PIC that is to be programmed. The intelligent type of programmer is needed to program earlier PIC models (mostly EPROM type) which do not support in-circuit programming.
Third party programmers range from plans to build your own, to self-assembly kits and fully tested ready-to-go units. Some are simple designs which require a PC to do the low-level programming signalling (these typically connect to the serial or parallel port and consist of a few simple components), while others have the programming logic built into them (these typically use a serial or USB connection, are usually faster, and are often built using PICs themselves for control).
==Debugging==
===In-circuit debugging===
All newer PIC devices feature an ICD (in-circuit debugging) interface, built into the CPU core, that allows for interactive debugging of the program in conjunction with MPLAB IDE. MPLAB ICD and MPLAB devices debuggers can communicate with this interface using the ICSP interface.
This debugging system comes at a price however, namely limited breakpoint count (1 on older devices, 3 on newer devices), loss of some I/O (with the exception of some surface mount 44-pin PICs which have dedicated lines for debugging) and loss of some on-chip features.
Some devices do not have on-chip debug support, due to cost or lack of pins. Some larger chips also have no debug module. To debug these devices, a special -ICD version of the chip mounted on a daughter board which provides dedicated ports is required. Some of these debug chips are able to operate as more than one type of chip by the use of selectable jumpers on the daughter board. This allows broadly identical architectures that do not feature all the on chip peripheral devices to be replaced by a single -ICD chip. For example: the 12F690-ICD will function as one of six different parts each of which features one, some or all of five on chip peripherals.<ref>Microchip document No. DS51292R</ref>
===In-circuit emulators===
Microchip offers three full in-circuit emulators: the MPLAB devices (parallel interface, a USB converter is available); the newer MPLAB devices (USB 2.0 connection); and most recently, the REAL ICE (USB 2.0 connection). All such tools are typically used in conjunction with MPLAB IDE for source-level interactive debugging of code running on the target.
==Operating systems==
PIC projects may utilize Real time operating systems such as FreeRTOS, AVIX RTOS, uRTOS, Salvo RTOS or other similar libraries for task scheduling and prioritization.
An open source project by Serge Vakulenko adapts 2.11BSD to the PIC32 architecture, under the name RetroBSD. This brings a familiar Unix-like operating system, including an onboard development environment, to the microcontroller, within the constraints of the onboard hardware.<ref name="RetroBSD"></ref>
==Clones==
===Parallax===
Parallax produced a series of PICmicro-like microcontrollers known as the Parallax SX. It is currently discontinued. Designed to be architecturally similar to the PIC microcontrollers used in the original versions of the BASIC Stamp, SX microcontrollers replaced the PIC in several subsequent versions of that product.
Parallax's SX are 8-bit RISC microcontrollers, using a 12-bit instruction word, which run fast at 75&nbsp;MHz (75 MIPS). They include up to 4096 12-bit words of flash memory and up to 262 bytes of random access memory, an eight bit counter and other support logic. There are software library modules to emulate I²C and SPI interfaces, UARTs, frequency generators, measurement counters and PWM and sigma-delta A/D converters. Other interfaces are relatively easy to write, and existing modules can be modified to get new features.
===PKK Milandr===
Russian PKK Milandr produces microcontrollers using the PIC17 architecture as the 1886 series.<ref></ref>
<ref></ref>
<ref name=milandr1886></ref>
<ref name=museum1886></ref>
Program memory consists of up to 64kB Flash memory in the 1886VE2U or 8kB EEPROM in the 1886VE5U (1886ВЕ5У). The 1886VE5U (1886ВЕ5У) through 1886VE7U (1886ВЕ7У) are specified for the military temperature range of -60&nbsp;°C to +125&nbsp;°C. Hardware interfaces in the various parts include USB, CAN, I2C, SPI, as well as A/D and D/A converters. The 1886VE3U (1886ВЕ3У) contains a hardware accelerator for cryptographic functions according to GOST 28147-89. There are even radiation-hardened chips with the designations 1886VE8U (1886ВЕ8У) and 1886VE10U (1886ВЕ10У).<ref></ref>
===ELAN Microelectronics===
ELAN Microelectronics Corp. in Taiwan make a line of microcontrollers based on the PIC16 architecture, with 13-bit instructions and a smaller (6-bit) RAM address space.<ref> urltoken 
===Holtek Semiconductor===
Holtek make a large number of very cheap microcontrollers<ref></ref> (as low as 8.5 cents in quantity<ref></ref>) with a 14-bit instruction set strikingly similar to the PIC16.
===Other manufacturers in Asia===
Many ultra-low-cost OTP microcontrollers from Asian manufacturers, found in low-cost consumer electronics are based on the PIC architecture or modified form. Most clones only target the baseline parts (PIC16C5x/PIC12C50x). Microchip has attempted to sue some manufacturers when the copying is particularly egregious,<ref></ref><ref></ref>
without success.<ref></ref><ref></ref>
==See also==
* PIC16x84
* Atmel AVR
* Arduino
* BASIC Atom
* BASIC Stamp
* OOPic
* PICAXE
* TI MSP430
* Maximite
==References==
==Further reading==
* Microcontroller Theory and Applications, with the PIC18F; 2nd Ed; M. Rafiquzzaman; Wiley; 544 pages; 2018; .
* Microcontroller System Design Using PIC18F Processors; Nicolas K. Haddad; IGI Global; 428 pages; 2017; .
* PIC Microcontroller Projects in C: Basic to Advanced (for PIC18F); 2nd Ed; Dogan Ibrahim; Newnes; 660 pages; 2014; . urltoken (1st Ed)
* Microcontroller Programming: Microchip PIC; Sanchez and Canton; CRC Press; 824 pages; 2006; . urltoken (1st Ed)
* PIC Microcontroller Project Book; John Iovine; TAB; 272 pages; 2000; . urltoken (1st Ed)
==External links==
<!-- 
 Please be cautious adding more external links.
Wikipedia is not a collection of links and should not be used for advertising.
 Excessive or inappropriate links will be removed.
 See Wikipedia:External links and Wikipedia:Spam for details.
If there are already suitable links, propose additions or replacements on
the article's talk page, or submit your link to the relevant category at 
the Open Directory Project (dmoz.org) and link there using .
-->
* .
* urltoken Official Microchip website
* urltoken PIC wifi projects website

Image:PIC microcontrollers.jpg|thumb|PIC microcontrollers in DIP and QFN packages
thumb
Image:PIC12C508-HD.jpg|thumb|Die of a PIC12C508 8-bit, fully static, EEPROM/EPROM/ROM-based CMOS microcontroller manufactured by Microchip Technology using a 1200 nanometre process
Image:PIC16C505-HD.jpg|thumb|Die of a PIC16C505 CMOS ROM-based 8-bit microcontroller manufactured by Microchip Technology using a 1200 nanometre process
PIC (usually pronounced as "pick") is a family of microcontrollers made by Microchip Technology, derived from the PIC1650<ref> urltoken name="PICmicrofamilytree">"PICmicro Family Tree", PIC16F Seminar Presentation </ref> originally developed by General Instrument's Microelectronics Division. The name PIC initially referred to Peripheral Interface Controller,<ref name="1976databook">"MOS DATA 1976", General Instrument 1976 Databook
</ref>
and is currently expanded as Programmable Intelligent Computer.<ref name="1977catalog">"1977 Data Catalog", Micro Electronics from General Instrument Corporation </ref>
The first parts of the family were available in 1976; by 2013 the company had shipped more than twelve billion individual parts, used in a wide variety of embedded systems.
Early models of PIC had read-only memory (ROM) or field-programmable EPROM for program storage, some with provision for erasing memory. All current models use flash memory for program storage, and newer models allow the PIC to reprogram itself. Program memory and data memory are separated. Data memory is 8-bit, 16-bit, and, in latest models, 32-bit wide. Program instructions vary in bit-count by family of PIC, and may be 12, 14, 16, or 24 bits long. The instruction set also varies by model, with more powerful chips adding instructions for digital signal processing functions.
The hardware capabilities of PIC devices range from 6-pin SMD, 8-pin DIP chips up to 144-pin SMD chips, with discrete I/O pins, ADC and DAC modules, and communications ports such as UART, I2C, CAN, and even USB. Low-power and high-speed variations exist for many types.
The manufacturer supplies computer software for development known as MPLAB, assemblers and C/C++ compilers, and programmer/debugger hardware under the MPLAB and PICKit series. Third party and some open-source tools are also available. Some parts have in-circuit programming capability; low-cost development programmers are available as well as high-production programmers.
PIC devices are popular with both industrial developers and hobbyists due to their low cost, wide availability, large user base, extensive collection of application notes, availability of low cost or free development tools, serial programming, and re-programmable flash-memory capability.
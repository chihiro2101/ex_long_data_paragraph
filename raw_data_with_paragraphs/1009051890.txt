Communicating sequential processes

== History ==
The version of CSP presented in Hoare's original 1978 article was essentially a concurrent programming language rather than a process calculus. It had a substantially different syntax than later versions of CSP, did not possess mathematically defined semantics,<ref name="hoare"></ref> and was unable to represent unbounded nondeterminism.<ref name="clinger1981"></ref> Programs in the original CSP were written as a parallel composition of a fixed number of sequential processes communicating with each other strictly through synchronous message-passing. In contrast to later versions of CSP, each process was assigned an explicit name, and the source or destination of a message was defined by specifying the name of the intended sending or receiving process. For example, the process
 COPY = *c:character; west?c → east!c
repeatedly receives a character from the process named <code>west</code> and sends that character to process named <code>east</code>. The parallel composition
 west::DISASSEMBLE || X::COPY || east::ASSEMBLE
assigns the names <code>west</code> to the <code>DISASSEMBLE</code> process, <code>X</code> to the <code>COPY</code> process, and <code>east</code> to the <code>ASSEMBLE</code> process, and executes these three processes concurrently.<ref name="hoare1978" />
Following the publication of the original version of CSP, Hoare, Stephen Brookes, and Bill Roscoe developed and refined the theory of CSP into its modern, process algebraic form. The approach taken in developing CSP into a process algebra was influenced by Robin Milner's work on the Calculus of Communicating Systems (CCS) and conversely. The theoretical version of CSP was initially presented in a 1984 article by Brookes, Hoare, and Roscoe,<ref></ref> and later in Hoare's book Communicating Sequential Processes,<ref name="hoare" /> which was published in 1985. In September 2006, that book was still the urltoken third-most cited computer science reference of all time according to Citeseer (albeit an unreliable source due to the nature of its sampling). The theory of CSP has undergone a few minor changes since the publication of Hoare's book. Most of these changes were motivated by the advent of automated tools for CSP process analysis and verification. Roscoe's The Theory and Practice of Concurrency<ref name="roscoe" /> describes this newer version of CSP.
=== Applications ===
An early and important application of CSP was its use for specification and verification of elements of the INMOS T9000 Transputer, a complex superscalar pipelined processor designed to support large-scale multiprocessing. CSP was employed in verifying the correctness of both the processor pipeline and the Virtual Channel Processor, which managed off-chip communications for the processor.<ref name="barrett" />
Industrial application of CSP to software design has usually focused on dependable and safety-critical systems. For example, the Bremen Institute for Safe Systems and Daimler-Benz Aerospace modeled a fault-management system and avionics interface (consisting of about 23,000 lines of code) intended for use on the International Space Station in CSP, and analyzed the model to confirm that their design was free of deadlock and livelock.<ref></ref><ref></ref> The modeling and analysis process was able to uncover a number of errors that would have been difficult to detect using testing alone. Similarly, Praxis High Integrity Systems applied CSP modeling and analysis during the development of software (approximately 100,000 lines of code) for a secure smart-card certification authority to verify that their design was secure and free of deadlock. Praxis claims that the system has a much lower defect rate than comparable systems.<ref name="hall" />
Since CSP is well-suited to modeling and analyzing systems that incorporate complex message exchanges, it has also been applied to the verification of communications and security protocols. A prominent example of this sort of application is Lowe’s use of CSP and the FDR2 to discover a previously unknown attack on the Needham–Schroeder protocol, and then to develop a corrected protocol able to defeat the attack.<ref></ref>
== Informal description ==
As its name suggests, CSP allows the description of systems in terms of component processes that operate independently, and interact with each other solely through message passing communication. However, the "Sequential" part of the CSP name is now something of a misnomer, since modern CSP allows component processes to be defined both as sequential processes, and as the parallel composition of more primitive processes. The relationships between different processes, and the way each process communicates with its environment, are described using various process calculi operators. Using this algebraic approach, quite complex process descriptions can be easily constructed from a few primitive elements.
=== Primitives ===
CSP provides two classes of primitives in its process algebra:
;Events
:Events represent communications or interactions. They are assumed to be indivisible and instantaneous. They may be atomic names (e.g. on, off), compound names (e.g. valve.open, valve.close), or input/output events (e.g. mouse?xy, screen!bitmap).
;Primitive processes:
:Primitive processes represent fundamental behaviors: examples include STOP (the process that communicates nothing, also called deadlock), and SKIP (which represents successful termination).
=== Algebraic operators ===
CSP has a wide range of algebraic operators. The principal ones are:
; Prefix
: The prefix operator combines an event and a process to produce a new process. For example,
:: <math>a \to P</math>
: is the process that is willing to communicate with its environment and, after , behaves like the process .
; Deterministic choice
: The deterministic (or external) choice operator allows the future evolution of a process to be defined as a choice between two component processes and allows the environment to resolve the choice by communicating an initial event for one of the processes. For example,
:: <math>(a \to P) \Box (b \to Q)</math>
: is the process that is willing to communicate the initial events and and subsequently behaves as either or , depending on which initial event the environment chooses to communicate. If both and were communicated simultaneously, the choice would be resolved nondeterministically.
; Nondeterministic choice
: The nondeterministic (or internal) choice operator allows the future evolution of a process to be defined as a choice between two component processes, but does not allow the environment any control over which one of the component processes will be selected. For example,
:: <math>(a \to P) \sqcap (b \to Q)</math>
: can behave like either <math>(a \to P)</math> or <math>(b \to Q)</math>. It can refuse to accept or and is only obliged to communicate if the environment offers both and . Nondeterminism can be inadvertently introduced into a nominally deterministic choice if the initial events of both sides of the choice are identical. So, for example,
:: <math>(a \to a \to \text</math>.
== Tools ==
Over the years, a number of tools for analyzing and understanding systems described using CSP have been produced. Early tool implementations used a variety of machine-readable syntaxes for CSP, making input files written for different tools incompatible. However, most CSP tools have now standardized on the machine-readable dialect of CSP devised by Bryan Scattergood, sometimes referred to as CSP<sub>M</sub>.<ref></ref> The CSP<sub>M</sub> dialect of CSP possesses a formally defined operational semantics, which includes an embedded functional programming language.
The most well-known CSP tool is probably Failures/Divergence Refinement 2 (FDR2), which is a commercial product developed by Formal Systems (Europe) Ltd. FDR2 is often described as a model checker, but is technically a refinement checker, in that it converts two CSP process expressions into Labelled transition system (LTSs), and then determines whether one of the processes is a refinement of the other within some specified semantic model (traces, failures, or failures/divergence).<ref></ref> FDR2 applies various state-space compression algorithms to the process LTSs in order to reduce the size of the state-space that must be explored during a refinement check. FDR2 has been succeeded by FDR3, a completely re-written version incorporating amongst other things parallel execution and an integrated type checker. It is released by the University of Oxford, which also released FDR2 in the period 2008-12.<ref></ref>
The Adelaide Refinement Checker (ARC)<ref></ref> is a CSP refinement checker developed by the Formal Modelling and Verification Group at The University of Adelaide. ARC differs from FDR2 in that it internally represents CSP processes as Binary decision diagram (OBDDs), which alleviates the state explosion problem of explicit LTS representations without requiring the use of state-space compression algorithms such as those used in FDR2.
The ProB project,<ref></ref> which is hosted by the Institut für Informatik, Heinrich-Heine-Universität Düsseldorf, was originally created to support analysis of specifications constructed in the B method. However, it also includes support for analysis of CSP processes both through refinement checking, and LTL model-checking. ProB can also be used to verify properties of combined CSP and B specifications. A ProBE CSP Animator is integrated in FDR3.
The Process Analysis Toolkit (PAT)
<ref></ref><ref></ref> is a CSP analysis tool developed in the School of Computing at the National University of Singapore. PAT is able to perform refinement checking, LTL model-checking, and simulation of CSP and Timed CSP processes. The PAT process language extends CSP with support for mutable shared variables, asynchronous message passing, and a variety of fairness and quantitative time related process constructs such as <code>deadline</code> and <code>waituntil</code>. The underlying design principle of the PAT process language is to combine a high-level specification language with procedural programs (e.g. an event in PAT may be a sequential program or even an external C# library call) for greater expressiveness. Mutable shared variables and asynchronous channels provide a convenient syntactic sugar for well-known process modelling patterns used in standard CSP. The PAT syntax is similar, but not identical, to CSP<sub>M</sub>.<ref></ref> The principal differences between the PAT syntax and standard CSP<sub>M</sub> are the use of semicolons to terminate process expressions, the inclusion of syntactic sugar for variables and assignments, and the use of slightly different syntax for internal choice and parallel composition.
VisualNets<ref></ref> produces animated visualisations of CSP systems from specifications, and supports timed CSP.
CSPsim<ref></ref> is a lazy simulator. It does not model check CSP, but is useful for exploring very large (potentially infinite) systems.
 urltoken SyncStitch is a CSP refinement checker with interactive modeling and analyzing environment. It has a graphical state-transition diagram editor. The user can model the behavior of processes as not only CSP expressions but also state-transition diagrams. The result of checking are also reported graphically as computation-trees and can be analyzed interactively with peripheral inspecting tools. In addition to refinement checks, It can perform deadlock check and livelock check.
== Related formalisms ==
Several other specification languages and formalisms have been derived from, or inspired by, the classic untimed CSP, including:
* urltoken Timed CSP, which incorporates timing information for reasoning about real-time systems
* urltoken Receptive Process Theory, a specialization of CSP that assumes an asynchronous (i.e. nonblocking) send operation
* urltoken CSPP
* urltoken HCSP
* urltoken TCOZ, an integration of Timed CSP and Object Z
* urltoken Circus, an integration of CSP and Z based on the Unifying Theories of Programming
* urltoken CML (COMPASS Modelling Language), a combination of urltoken Circus and VDM developed for the modelling of System of systems (SoS)
* urltoken CspCASL, an extension of CASL that integrates CSP
* LOTOS, an international standard<ref>Language Of Temporal Ordering Specification</ref> that incorporates features of CSP and CCS.
* urltoken PALPS, a probabilistic extension with locations for ecological models developed by Anna Philippou and 
== Comparison with the actor model ==
In as much as it is concerned with concurrent processes that exchange messages, the actor model is broadly similar to CSP. However, the two models make some fundamentally different choices with regard to the primitives they provide:
* CSP processes are anonymous, while actors have identities.
* CSP uses explicit channels for message passing, whereas actor systems transmit messages to named destination actors. These approaches may be considered duals of each other, in the sense that processes receiving through a single channel effectively have an identity corresponding to that channel, while the name-based coupling between actors may be broken by constructing actors that behave as channels.
* CSP message-passing fundamentally involves a rendezvous between the processes involved in sending and receiving the message, i.e. the sender cannot transmit a message until the receiver is ready to accept it. In contrast, message-passing in actor systems is fundamentally asynchronous, i.e. message transmission and reception do not have to happen at the same time, and senders may transmit messages before receivers are ready to accept them. These approaches may also be considered duals of each other, in the sense that rendezvous-based systems can be used to construct buffered communications that behave as asynchronous messaging systems, while asynchronous systems can be used to construct rendezvous-style communications by using a message/acknowledgement protocol to synchronize senders and receivers.

In computer science, communicating sequential processes (CSP) is a formal language for describing patterns of interaction in concurrent systems.<ref name="roscoe"></ref> It is a member of the family of mathematical theories of concurrency known as process algebras, or process calculi, based on message passing via channels. CSP was highly influential in the design of the occam programming language<ref name="roscoe" /><ref>, INMOS document 72 occ 45 03.</ref> and also influenced the design of programming languages such as Limbo,<ref></ref> RaftLib, Go,<ref name="golang"></ref> Crystal, and Clojure's core.async.<ref name="clojure-core-async"></ref>
CSP was first described in a 1978 article by Tony Hoare,<ref name="hoare1978"></ref> but has since evolved substantially.<ref name="25years"></ref> CSP has been practically applied in industry as a tool for formal specification the concurrent aspects of a variety of different systems, such as the T9000 Transputer,<ref name="barrett"></ref> as well as a secure ecommerce system.<ref name="hall"></ref> The theory of CSP itself is also still the subject of active research, including work to increase its range of practical applicability (e.g., increasing the scale of the systems that can be tractably analyzed).<ref></ref>
Transposition table

== Functionality ==
Game-playing programs work by analyzing millions of positions that could arise in the next few moves of the game. Typically, these programs employ strategies resembling depth-first search, which means that they do not keep track of all the positions analyzed so far. In many games, it is possible to reach a given position in more than one way. These are called transpositions.<ref> urltoken Transposition Tables, Gamedev.net, Francois-Dominic Laramee.</ref> In chess, for example, the sequence of moves 1. d4 Nf6 2. c4 g6 (see algebraic chess notation) has 4 possible transpositions, since either player may swap their move order. In general, after n moves, an upper limit on the possible transpositions is (n!)<sup>2</sup>. Although many of these are illegal move sequences, it is still likely that the program will end up analyzing the same position several times.
To avoid this problem, transposition tables are used. Such a table is a hash table of each of the positions analyzed so far up to a certain depth. On encountering a new position, the program checks the table to see whether the position has already been analyzed; this can be done quickly, in amortized constant time. If so, the table contains the value that was previously assigned to this position; this value is used directly. If not, the value is computed, and the new position is entered into the hash table.
The number of positions searched by a computer often greatly exceeds the memory constraints of the system it runs on; thus not all positions can be stored. When the table fills up, less-used positions are removed to make room for new ones; this makes the transposition table a kind of cache.
The computation saved by a transposition table lookup is not just the evaluation of a single position. Instead, the evaluation of an entire subtree is avoided. Thus, transposition table entries for nodes at a shallower depth in the game tree are more valuable (since the size of the subtree rooted at such a node is larger) and are therefore given more importance when the table fills up and some entries must be discarded.
The hash table implementing the transposition table can have other uses than finding transpositions. In alphaâ€“beta pruning, the search is fastest (in fact, optimal) when the child of a node corresponding to the best move is always considered first. Of course, there is no way of knowing the best move beforehand, but when iterative deepening is used, the move that was found to be the best in a shallower search is a good approximation. Therefore this move is tried first. For storing the best child of a node, the entry corresponding to that node in the transposition table is used.
Use of a transposition table can lead to incorrect results if the graph-history interaction problem is not studiously avoided. This problem arises in certain games because the history of a position may be important. For example, in chess a player may not castle if the king or the rook to be castled with has moved during the course of the game. A common solution to this problem is to add the castling rights as part of the Zobrist hashing key. Another example is draw by repetition: given a position, it may not be possible to determine whether it has already occurred. A solution to the general problem is to store history information in each node of the transposition table, but this is inefficient and rarely done in practice.
== Replacement strategies ==
A transposition table is a cache whose maximum size is limited by available system memory, and it may overflow at any time. In fact, it is expected to overflow, and the number of positions cacheable at any time may be only a small fraction (even orders of magnitude smaller) than the number of nodes in the game tree. The vast majority of nodes are not transposition nodes, i.e. positions that will recur, so effective replacement strategies that retain potential transposition nodes and replace other nodes can result in significantly reduced tree size. Replacement is usually based on tree depth and aging: nodes higher in the tree (closer to the root) are favored, because the subtrees below them are larger and result in greater savings; and more recent nodes are favored because older nodes are no longer similar to the current position, so transpositions to them are less likely.
Other strategies are to retain nodes in the principal variation, nodes with larger subtrees regardless of depth in the tree, and nodes that caused cutoffs.
== Size and performance ==
Though the fraction of nodes that will be transpositions is small, the game tree is an exponential structure, so cacheing a very small number of such nodes can make a significant difference. In chess, search time reductions of 0-50% in complex middle game positions and up to a factor of 5 in the end game have been reported.<ref>Atkin, L. and Slate, D., 1977, "Chess 4.5, the Northwestern University Chess Program", in Chess Skill in Man and Machine, Peter W. Frey, Ed. Springer-Verlag, New York, NY</ref>
==Related techniques==
* Similar techniques can be used to cache evaluations of certain features of a position. For example, a pawn hash table can be used to store an evaluation of the pawn structures in a position. Since the number of pawn positions examined is generally much smaller than the total number of positions searched, the pawn hash table has a very high hit rate, allowing a program to spend more time on sophisticated pawn evaluations because they are reused many times.
* A refutation table can be used to store sequences of moves from the root node to leaf nodes. This includes the principal variation and responses to other lines showing that they are inferior. Refutation tables were sometimes used instead of transposition tables in the earlier years of computer chess, when memory was more limited. Some modern chess programs use refutation tables in addition to transposition tables for move ordering.
*Static bitmaps of the possible moves of each type of piece on each space of the board can be cached at program initialization, so that the legal moves of a piece (or together, all legal moves for move generation) can be retrieved with a single memory load instead of having to be serially enumerated. These are commonly used in bitboard implementations.
==See also==
* Minimax algorithm
* Alpha-beta pruning
* Zobrist hashing
==Notes and references==
<references/>
==External links==
* urltoken Transposition Tables Sigmachess.com
* urltoken Technical The Main Transposition Table (information on the data structure and implementation)
* urltoken The anatomy of chess programs T.A. Marsland, University of Alberta
* urltoken Transposition Table The Chess Programming Wiki

A transposition table is a cache of previously seen positions, and associated evaluations, in a game tree generated by a computer game playing program. If a position recurs via a different sequence of moves, the value of the position is retrieved from the table, avoiding re-searching the game tree below that position. Transposition tables are primarily useful in perfect-information games (where the entire state of the game is known to all players at all times). The usage of transposition tables is essentially memoization applied to the tree search and is a form of dynamic programming. 
Transposition tables are typically implemented as hash tables encoding the current board position as the hash index. The number of possible positions that may occur in a game tree is an exponential function of depth of search, and can be thousands to millions or even much greater. Transposition tables may therefore consume most of available system memory and are usually most of the memory footprint of game playing programs.